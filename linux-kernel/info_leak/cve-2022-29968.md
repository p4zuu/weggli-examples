# CVE-2022-29968

An issue was discovered in the Linux kernel through 5.17.5. io_rw_init_file in
fs/io_uring.c lacks initialization of kiocb->private.

## Weggli query

```sh
 weggli -R func=init '_ $func(_){ 
 struct _* $s = _;
 NOT: kzalloc($d, _);
 NOT: memset($d, 0, _);
 }' fs/io_uring.c 
```

## Output

```c
$  weggli -R func=init '_ $func(_){                                                                                                                                                                                            [±master ●]
 struct _* $s = _;
 NOT: kzalloc($d, _);
 NOT: memset($d, 0, _);
 }' fs/io_uring.c
 
kernel/fs/io_uring.c:3755
static int io_rw_init_file(struct io_kiocb *req, fmode_t mode)
{
        struct kiocb *kiocb = &req->rw.kiocb;
        struct io_ring_ctx *ctx = req->ctx;
        struct file *file = req->file;
        int ret;

        if (unlikely(!file || !(file->f_mode & mode)))
..
}
kernel/fs/io_uring.c:3755
static int io_rw_init_file(struct io_kiocb *req, fmode_t mode)
{
        struct kiocb *kiocb = &req->rw.kiocb;
        struct io_ring_ctx *ctx = req->ctx;
        struct file *file = req->file;
        int ret;

        if (unlikely(!file || !(file->f_mode & mode)))
                return -EBADF;
..
}
kernel/fs/io_uring.c:3755
static int io_rw_init_file(struct io_kiocb *req, fmode_t mode) // Uninitialized value in this one
{
        struct kiocb *kiocb = &req->rw.kiocb;
        struct io_ring_ctx *ctx = req->ctx;
        struct file *file = req->file;
        int ret;

        if (unlikely(!file || !(file->f_mode & mode)))
                return -EBADF;

..
}
kernel/fs/io_uring.c:7577
static void io_init_req_drain(struct io_kiocb *req)
{
        struct io_ring_ctx *ctx = req->ctx;
        struct io_kiocb *head = ctx->submit_state.link.head;

        ctx->drain_active = true;
        if (head) {
                
..
}
kernel/fs/io_uring.c:7577
static void io_init_req_drain(struct io_kiocb *req)
{
        struct io_ring_ctx *ctx = req->ctx;
        struct io_kiocb *head = ctx->submit_state.link.head;

        ctx->drain_active = true;
        if (head) {
..
}

```

## The bugy function

```c
static int io_rw_init_file(struct io_kiocb *req, fmode_t mode)
{
	struct kiocb *kiocb = &req->rw.kiocb;
	struct io_ring_ctx *ctx = req->ctx;
	struct file *file = req->file;
	int ret;

	if (unlikely(!file || !(file->f_mode & mode)))
		return -EBADF;

	if (!io_req_ffs_set(req))
		req->flags |= io_file_get_flags(file) << REQ_F_SUPPORT_NOWAIT_BIT;

	kiocb->ki_flags = iocb_flags(file);
	ret = kiocb_set_rw_flags(kiocb, req->rw.flags);
	if (unlikely(ret))
		return ret;

	/*
	 * If the file is marked O_NONBLOCK, still allow retry for it if it
	 * supports async. Otherwise it's impossible to use O_NONBLOCK files
	 * reliably. If not, or it IOCB_NOWAIT is set, don't retry.
	 */
	if ((kiocb->ki_flags & IOCB_NOWAIT) ||
	    ((file->f_flags & O_NONBLOCK) && !io_file_supports_nowait(req)))
		req->flags |= REQ_F_NOWAIT;

	if (ctx->flags & IORING_SETUP_IOPOLL) {
		if (!(kiocb->ki_flags & IOCB_DIRECT) || !file->f_op->iopoll)
			return -EOPNOTSUPP;
		
		/* kiocb->private initialization is missing here */
		kiocb->ki_flags |= IOCB_HIPRI | IOCB_ALLOC_CACHE;
		kiocb->ki_complete = io_complete_rw_iopoll;
		req->iopoll_completed = 0;
	} else {
		if (kiocb->ki_flags & IOCB_HIPRI)
			return -EINVAL;
		kiocb->ki_complete = io_complete_rw;
	}

	return 0;
}
```


## Fix

[io_uring: fix uninitialized field in rw io_kiocb](https://github.com/torvalds/linux/commit/32452a3eb8b64e01e2be717f518c0be046975b9dhttps://github.com/torvalds/linux/commit/32452a3eb8b64e01e2be717f518c0be046975b9d)